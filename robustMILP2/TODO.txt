- make it possible to have multiple beziers for one specification (one time-range)      DONE
- implement the until operator
- implement overlapping time-ranges                                                     DONE
- implement obstacles




#### MPC LIKE IN main
# global t, BSTL, spec, ax_anim
# t = 0
# tf = 13
# N = 5

# Neval = 14

# fig = plt.figure(figsize=(10,10))
# ax_anim = plt.axes()

# spec = Spec(0,13)
# robot = SingleIntegrator(spec.tf,N,v_max=2)

# world_size = MySquare([5,5],6.5)
# world = World()
# world.add_world_size(world_size)

# BSTL = BezierSTL(spec, robot, N, world=world)
# BSTL.construct(bezier_order=5)
# BSTL.add_cost()
# BSTL.solve()
# BSTL.evaluate()

# def animate_MPC():
#     anim = animation.FuncAnimation(fig,animate_update,frames=Neval)
#     anim.save("planning/robustMILP2/figures/anim_mpc.mp4",
#               writer='ffmpeg',fps=2)

# def animate_update(anim_i):
#     global t, BSTL, spec
#     ax_anim.clear()
#     t += 0.2 #tf/Neval

#     q, dq, idx = BSTL.eval_q(t)

#     spec = Spec(t,tf)
#     spec.q0 = q[:,0]
#     print(spec.q0)
#     spec.dq0 = dq[:,0]

#     BSTL = BezierSTL(spec, robot, N-idx, world=world)
#     BSTL.construct(bezier_order=5)
#     BSTL.add_cost()
#     BSTL.solve()
#     BSTL.evaluate()

#     # plot the world
#     BSTL.world.plot(ax_anim)
#     # plot the trajectory
#     for i in range(BSTL.N):
#         ax_anim.plot(BSTL.bSols[i].r_cps[0,:],BSTL.bSols[i].r_cps[1,:],'ro',markersize=4)
#         # the start and end control point in blue
#         ax_anim.plot(BSTL.bSols[i].r_cps[0,0],BSTL.bSols[i].r_cps[1,0],'bo',markersize=4)
#         ax_anim.plot(BSTL.bSols[i].r_cps[0,-1],BSTL.bSols[i].r_cps[1,-1],'bo',markersize=4)
#     for i in range(BSTL.N):
#         ax_anim.plot(BSTL.bSols[i].r_eval[0,:],BSTL.bSols[i].r_eval[1,:],'k',markersize=4)
#     ax_anim.grid(True)
#     ax_anim.set_xlabel('x [m]')
#     ax_anim.set_ylabel('y [m]')
#     ax_anim.set_title('position')
#     ax_anim.set_aspect('equal')

#     return ax_anim











            elif pred.io == "out": # stay-out
                ys = obj.prog.addMVar((n_faces,1),vtype=GRB.BINARY)

                for i in range(n_faces):
                    mu = b[i] - ineqs[i]
                    obj.prog.addConstr(mu <= (obj.bigM)*(1-ys[i]))
                # now have z_space be true if this constraint holds 
                obj.prog.addConstr(pred.z_space[idx] <= gp.quicksum(ys))
                for i in range(n_faces):
                    obj.prog.addConstr(pred.z_space[idx] >= ys[i])